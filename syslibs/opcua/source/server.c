
/******************************************************************************
*
*   FILE
*   ----
*   uaServer.c
*
*   History
*   -------
*   2019-01-16   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif


#include "opcua.h"
#include "ov_macros.h"
#include "ov_object.h" //for ov_object_getaccessEx
#include "helpers.h"
#include "ovSwitch.h"
#include "ovTrafo.h"
#include "nsSwitch.h"

OV_DLLFNCEXPORT OV_RESULT opcua_server_applicationURI_set(
    OV_INSTPTR_opcua_server         pobj,
    const OV_STRING  value
) {
	if(pobj->v_isRunning){
        return OV_ERR_GENERIC;
	}
    return ov_string_setvalue(&pobj->v_applicationURI,value);
}

OV_DLLFNCEXPORT OV_RESULT opcua_server_applicationName_set(
    OV_INSTPTR_opcua_server          pobj,
    const OV_STRING  value
) {
	if(pobj->v_isRunning){
        return OV_ERR_GENERIC;
	}
    return ov_string_setvalue(&pobj->v_applicationName,value);
}

OV_DLLFNCEXPORT OV_RESULT opcua_server_port_set(
    OV_INSTPTR_opcua_server          pobj,
    const OV_UINT  value
) {
	if(value > 0 && value < 65535){
		if(pobj->v_isRunning){
        	return OV_ERR_GENERIC;
		}
	    pobj->v_port = value;
	    return OV_ERR_OK;
	}else
		return OV_ERR_BADPARAM;
}

UA_StatusCode opcua_server_setConfig(OV_INSTPTR_opcua_server pServer){
	UA_StatusCode result = UA_STATUSCODE_GOOD;
	UA_ServerConfig* config = UA_Server_getConfig(pServer->v_server);
	result = UA_ServerConfig_setMinimal(config, pServer->v_port, NULL);
	if (result != UA_STATUSCODE_GOOD)
		return result;

	//Delete old application name and uri
    UA_String_clear(&config->applicationDescription.applicationName.text);
    UA_String_clear(&config->applicationDescription.applicationUri);

    //Fill in application name
    if(pServer != NULL && ov_string_getlength(pServer->v_applicationName)){
    	config->applicationDescription.applicationName.text = UA_String_fromChars(pServer->v_applicationName);
    }else{
    	//Append OPCUA_DEFAULT_APPLICATIONNAME and SERVERNAME
    	OV_ANY serverName = OV_ANY_INIT;
    	OV_STRING applicationName = NULL;
    	ov_vendortree_getservername(&serverName, NULL); //Do not free, points to static servername
    	ov_string_print(&applicationName,"%s/%s",  OPCUA_DEFAULT_APPLICATIONNAME, serverName.value.valueunion.val_string);
    	config->applicationDescription.applicationName.text = UA_String_fromChars(applicationName);
    	ov_string_setvalue(&applicationName, NULL);
    }

    //Fill in application uri
    if(pServer != NULL && ov_string_getlength(pServer->v_applicationURI)){
    	config->applicationDescription.applicationUri = UA_String_fromChars(pServer->v_applicationURI);
    }else{
    	config->applicationDescription.applicationUri = UA_String_fromChars(OPCUA_DEFAULT_APPLICATIONURI);
    }

    //Copy application name and uri to endpoint spec //TODO issue in open62541
	for(size_t i=0 ; i < config->endpointsSize ; i++){
	    UA_String_clear(&config->endpoints[i].server.applicationName.text);
	    UA_String_clear(&config->endpoints[i].server.applicationUri);
		UA_String_copy(&config->applicationDescription.applicationName.text, &config->endpoints[i].server.applicationName.text);
		UA_String_copy(&config->applicationDescription.applicationUri, &config->endpoints[i].server.applicationUri);
	}

    //Set ov logger
    config->logger = opcua_ovUAlogger_new();

    return UA_STATUSCODE_GOOD;
}

//TODO move server startup and shutdown to typemethod?
//TODO write some static functions and proper error clean up (goto error/cleanup)
//TODO write errors to log file?
OV_DLLFNCEXPORT OV_RESULT opcua_server_run_set(
    OV_INSTPTR_opcua_server          pobj,
    const OV_BOOL  value
) {
	UA_StatusCode retval = UA_STATUSCODE_GOOD;
	if(pobj->v_error)
		return OV_ERR_GENERIC;

	if(value != pobj->v_run){
		if(value){ //start server
			
			//Create new server
			pobj->v_server = UA_Server_new();
			if(!pobj->v_server){
				ov_string_setvalue(&pobj->v_errorText, "UA_Server_new failed.");
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC;
			}

			pobj->v_ovSwitch = opcua_ovSwitch_new(pobj);
			if(!pobj->v_ovSwitch){
				ov_string_setvalue(&pobj->v_errorText, "opcua_ovSwitch_new failed.");
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC;
			}
			pobj->v_ovTrafo = opcua_ovTrafo_new(pobj);
			if(!pobj->v_ovTrafo){
				ov_string_setvalue(&pobj->v_errorText, "opcua_ovTrafo_new failed.");
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC;
			}

		    //Create new config
			retval = opcua_server_setConfig(pobj);
			if(retval != UA_STATUSCODE_GOOD){
				ov_string_print(&pobj->v_errorText, "UA_Server_run_startup failed: %s" , UA_StatusCode_name(retval));
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC;
			}

			//create new fresh nsSwitch in createConfig instead
			UA_ServerConfig *config = UA_Server_getConfig(pobj->v_server);

			UA_Nodestore_Switch* nsSwitch = NULL;
			UA_StatusCode result = UA_Nodestore_Switch_newEmpty(&nsSwitch);
			if (result != UA_STATUSCODE_GOOD){
				return OV_ERR_GENERIC;
			}
			UA_Nodestore * defaultNodestore = (UA_Nodestore*) UA_malloc(sizeof(UA_Nodestore));
			defaultNodestore->context = config->nodestore.context;
			defaultNodestore->clear = config->nodestore.clear;
			defaultNodestore->newNode = config->nodestore.newNode;
			defaultNodestore->deleteNode = config->nodestore.deleteNode;
			defaultNodestore->getNode = config->nodestore.getNode;
			defaultNodestore->releaseNode = config->nodestore.releaseNode;
			defaultNodestore->getNodeCopy = config->nodestore.getNodeCopy;
			defaultNodestore->insertNode = config->nodestore.insertNode;
			defaultNodestore->replaceNode = config->nodestore.replaceNode;
			defaultNodestore->iterate = config->nodestore.iterate;
			defaultNodestore->removeNode = config->nodestore.removeNode;
			defaultNodestore->getReferenceTypeId = config->nodestore.getReferenceTypeId;

			result = UA_Nodestore_Switch_setNodestoreDefault(nsSwitch, defaultNodestore);
			if (result != UA_STATUSCODE_GOOD){
				return OV_ERR_GENERIC;
			}

			UA_Nodestore_Switch_link(&config->nodestore, nsSwitch);

			//Load ovSwitch in nsSwitch
			result = UA_Nodestore_Switch_setNodestore(nsSwitch, OV_OPCUA_DEFAULTNSINDEX, pobj->v_ovSwitch);
			if (result != UA_STATUSCODE_GOOD){
				return OV_ERR_GENERIC;
			}

			//Load custom interface if linked and add references from NS0 to OV trafo adress space
			OV_INSTPTR_opcua_interface pInterface = Ov_GetChild(opcua_serverToInterfaces, pobj);
			if(pInterface){
				Ov_Call1(opcua_interface, pInterface, load, pobj->v_server);
				if(pInterface->v_useOvTrafo)
					opcua_helpers_addReferencesToTrafo(pobj->v_server, pInterface->v_entryPath);
			}
			else
			{
				opcua_helpers_addReferencesToTrafo(pobj->v_server, "/");
			}

		    //Startup server
			retval = UA_Server_run_startup(pobj->v_server);
			if(retval != UA_STATUSCODE_GOOD){
				ov_string_print(&pobj->v_errorText, "UA_Server_run_startup failed: %s" , UA_StatusCode_name(retval));
				pobj->v_error = TRUE;
				return OV_ERR_GENERIC;
			}

			pobj->v_isRunning = TRUE;

			//Add opc.tcp port and protocol to server representation
	    	OV_ANY serverName = OV_ANY_INIT;
	    	ov_vendortree_getservername(&serverName, NULL); //Do not free, points to static servername
	    	OV_STRING serverPortStr = NULL;
	    	ov_string_print(&serverPortStr, "%d", pobj->v_port);
			ksbase_Manager_register(serverName.value.valueunion.val_string,
					2, //TODO define constant
					"OPC.TCP",//TODO get from config : config->endpoints->endpointDescription.... or config->networkLayers-> ...
					serverPortStr,
					30); //TODO define constant
			ov_string_setvalue(&serverPortStr, NULL);

		}else{
			//Shutdown server
			retval = UA_Server_run_shutdown(pobj->v_server); //Always returns good
			UA_Server_delete(pobj->v_server);
			pobj->v_server = NULL;

			//Unregister opc.tcp port and protocol to server representation
	    	OV_ANY serverName = OV_ANY_INIT;
	    	ov_vendortree_getservername(&serverName, NULL); //Do not free, points to static servername
			ksbase_Manager_unregister(serverName.value.valueunion.val_string, //TODO check what happens, when multiple servers are registered with OPC.TCP --> adapt unregister function for multiple ports
					2, //TODO define constant for ov version, as vendortree version is 1.3.1 or 2.0.0
					"OPC.TCP");//TODO get from config : config->endpoints->endpointDescription.... or config->networkLayers-> ...

			pobj->v_isRunning = FALSE;
			if(retval != UA_STATUSCODE_GOOD){
				ov_string_print(&pobj->v_errorText, "UA_Server_run_shutdown failed: %s" , UA_StatusCode_name(retval));
				pobj->v_error = TRUE;
			}
		}
	    pobj->v_run = value;
	}
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT opcua_server_reset_set(
    OV_INSTPTR_opcua_server          pobj,
    const OV_BOOL  value
) {
    if(value){
    	pobj->v_error = FALSE;
    	opcua_server_run_set(pobj, FALSE);
    }
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void opcua_server_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*
    *   local variables
    */
    OV_INSTPTR_opcua_server pinst = Ov_StaticPtrCast(opcua_server, pobj);

    /* do what the base class does first */
    ov_object_startup(pobj);

    /* do what */
    //Restore running state from shutdown
    opcua_server_run_set(pinst, pinst->v_isRunning);

    return;
}

OV_DLLFNCEXPORT void opcua_server_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_opcua_server pinst = Ov_StaticPtrCast(opcua_server, pobj);

    /* do what */
    OV_BOOL isRunning = pinst->v_isRunning; //Save running state
	if (pinst->v_run == TRUE){
		opcua_server_run_set(pinst, FALSE);
	}

    pinst->v_isRunning = isRunning; //Restore running state

    /* set the object's state to "shut down" */
    ov_object_shutdown(pobj);

    return;
}

OV_DLLFNCEXPORT OV_ACCESS opcua_server_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	return ov_object_getaccessEx(pobj, pelem, pticket);
}

OV_DLLFNCEXPORT void opcua_server_typemethod (
	OV_INSTPTR_ksbase_ComTask	this
) {
    /*    
    *   local variables
    */
	OV_INSTPTR_opcua_server pinst = Ov_StaticPtrCast(opcua_server, this);
	if(pinst->v_isRunning){
		/* timeout is the maximum possible delay (in millisec) until the next
		   _iterate call. Otherwise, the server might miss an internal timeout
		   or cannot react to messages with the promised responsiveness. */
		/* If multicast discovery server is enabled, the timeout does not not consider new input data (requests) on the mDNS socket.
		 * It will be handled on the next call, which may be too late for requesting clients.
		 * if needed, the select with timeout on the multicast socket server->mdnsSocket (see example in mdnsd library)
		 */
//		UA_UInt16 timeout = UA_Server_run_iterate(pinst->v_server, FALSE);
		UA_Server_run_iterate(pinst->v_server, FALSE);
		/* Now we can use the max timeout to do something else. In this case, we
		   just sleep. (select is used as a platform-independent sleep
		   function.)
		struct timeval tv;
		tv.tv_sec = 0;
		tv.tv_usec = timeout * 1000;
		select(0, NULL, NULL, NULL, &tv);
	    */
	}
    return;
}

